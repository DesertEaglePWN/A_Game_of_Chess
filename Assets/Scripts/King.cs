//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class King : ChessPiece
{
    public bool CanCastle { get; set; }
    public ChessPiece CastlingRook { get; set; }
    public bool isChecked { get; set; }
    public override BoardSpace[] GetAvailableSpaces()
    {
        //Debug.Log (activeSpace.getSpace(SpaceDirection.Front,PieceColor));
        List<BoardSpace> possibleSpaces = new List<BoardSpace>();

        //GET BASE MOVE AND CAPTURE SPACES
        BoardSpace tempSpace, leftSpace, rightSpace;
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.FrontLeft, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Front, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.FrontRight, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }
        leftSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Left, PieceColor, true);
        if ((leftSpace != null) && (leftSpace.spaceState != SpaceState.Blocked) && (leftSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(leftSpace);
        }
        //Debug.Log(currentSpace);
        rightSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Right, PieceColor, true);
        //Debug.Log(rightSpace);
        if ((rightSpace != null) && (rightSpace.spaceState != SpaceState.Blocked) && (rightSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(rightSpace);
        }
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.BackLeft, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Back, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.BackRight, PieceColor, true);
        if ((tempSpace != null) && (tempSpace.spaceState != SpaceState.Blocked) && (tempSpace.spaceState != SpaceState.Contested))
        {
            possibleSpaces.Add(tempSpace);
        }

        //REMOVE CHECKED SPACES
        BoardSpace[] checkedSpaces = getCheckedSpaces();
        foreach (BoardSpace checkedSpace in checkedSpaces)
        {
            possibleSpaces.Remove(checkedSpace);
        }

        if (!bHasMoved)
        {
            leftSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Left, PieceColor, false);
            while (leftSpace != null)
            {
                GameManager.currentInstance.Board.checkSpace(leftSpace);
                if ((leftSpace.spaceState == SpaceState.Blocked))
                {
                    if ((leftSpace.OccupyingPiece.GetType() == typeof(Rook)) && !(leftSpace.OccupyingPiece.bHasMoved))
                    {
                        leftSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Left, PieceColor, false);
                        possibleSpaces.Add(GameManager.currentInstance.Board.getAdjacentSpace(leftSpace, SpaceDirection.Left, PieceColor, false));
                        CanCastle = true;
                        break;
                    }
                    break;
                }
                else if ((leftSpace.spaceState != SpaceState.Open) || (leftSpace.spaceState == SpaceState.Default))
                {
                    break;
                }
                leftSpace = GameManager.currentInstance.Board.getAdjacentSpace(leftSpace, SpaceDirection.Left, PieceColor, false);
            }
            rightSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Right, PieceColor, false);
            while (rightSpace != null)
            {
                GameManager.currentInstance.Board.checkSpace(rightSpace);
                if ((rightSpace.spaceState == SpaceState.Blocked))
                {
                    if ((rightSpace.OccupyingPiece.GetType() == typeof(Rook)) && !(rightSpace.OccupyingPiece.bHasMoved))
                    {
                        rightSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Right, PieceColor, false);
                        possibleSpaces.Add(GameManager.currentInstance.Board.getAdjacentSpace(rightSpace, SpaceDirection.Right, PieceColor, false));
                        CanCastle = true;
                        break;
                    }
                    break;
                }
                else if ((rightSpace.spaceState != SpaceState.Open) || (rightSpace.spaceState == SpaceState.Default))
                {
                    break;
                }
                rightSpace = GameManager.currentInstance.Board.getAdjacentSpace(rightSpace, SpaceDirection.Right, PieceColor, false);
            }
        }
        Debug.Log("Possible moves");
        foreach (BoardSpace space in possibleSpaces.ToArray())
        {
            Debug.Log(space);
        }
        return possibleSpaces.ToArray(); //return possibleSpaces as an array
        }
        
 


    ///// <summary>
    ///// Returns true if the King is in check from a piece in the specified direction.
    ///// </summary>
    ///// <param name="direction"></param>
    ///// <returns></returns>
    //private bool checkedFromDirection(SpaceDirection direction)
    //{
    //    BoardSpace checkSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, direction, PieceColor);
    //    switch (direction)
    //    {
    //        case (SpaceDirection.FrontLeft):
    //            while ((checkSpace != null) && (GameManager.currentInstance.Board.isSpaceAvailable(checkSpace, PieceColor)))
    //            {
    //                if ((checkSpace.OccupyingPiece != null))
    //                {
    //                    Type occupyingPieceType = checkSpace.OccupyingPiece.GetType();
    //                }
    //                if (checkSpace.spaceState == SpaceState.Contested)
    //                {
    //                    break;
    //                }
    //                checkSpace = GameManager.currentInstance.Board.getAdjacentSpace(checkSpace, direction, PieceColor);
    //            }
    //            break;
    //    }
    //    return false;
    //}


    private BoardSpace[] getCheckedSpaces()
    {
        List<BoardSpace> checkedSpaces = new List<BoardSpace>();
        BoardSpace tempSpace = currentSpace;

        //FRONTLEFT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.FrontLeft, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                //tempSpace.spaceState = SpaceState.Blocked;
                checkedSpaces.Add(tempSpace);
            }
        }
        //FRONT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Front, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //FRONTRIGHT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.FrontRight, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //LEFT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Left, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //RIGHT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Right, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //BACKLEFT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.BackLeft, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //BACK SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.Back, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }

        //BACKRIGHT SPACE
        tempSpace = GameManager.currentInstance.Board.getAdjacentSpace(currentSpace, SpaceDirection.BackRight, PieceColor, false);
        if (tempSpace != null)
        {
            if (GameManager.currentInstance.Board.isSpaceChecked(tempSpace, PieceColor))
            {
                checkedSpaces.Add(tempSpace);
            }
        }
        Debug.Log("CheckedSpaces");
        foreach (BoardSpace space in checkedSpaces)
        {
            Debug.Log(space);
        }
        return checkedSpaces.ToArray();
    }


    public bool isKingChecked()
    {
        switch (PieceColor)
        {
            case TeamColor.White:
                return GameManager.currentInstance.Board.isSpaceChecked(currentSpace, TeamColor.White);
            case TeamColor.Black:
                return GameManager.currentInstance.Board.isSpaceChecked(currentSpace, TeamColor.Black);
            case TeamColor.None:
                break;
        }
        return false;
    }

}